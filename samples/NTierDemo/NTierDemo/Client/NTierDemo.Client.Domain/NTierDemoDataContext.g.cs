//------------------------------------------------------------------------------
// <autogenerated>
//   This file was generated by T4 code generator NTierDemoModel_NTierEntityGenerator.tt.
//   Any changes made to this file manually may cause incorrect behavior
//   and will be lost next time the file is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;
using System.Data;
using System.Linq;
using System.ServiceModel;
using System.Transactions;
using NTier.Client.Domain;
using NTier.Client.Domain.Service.ChannelFactory;
using NTier.Common.Domain.Model;
using NTierDemo.Common.Domain.Model.NTierDemo;
using NTierDemo.Common.Domain.Service.Contracts;

namespace NTierDemo.Client.Domain
{
    public sealed partial class NTierDemoDataContext : DataContext<NTierDemoResultSet>, INTierDemoDataContext
    {
        #region Fields

        private readonly Func<INTierDemoDataService> _dataServiceFactory;
        private readonly InternalEntitySet<User> _users;
        private readonly InternalEntitySet<Blog> _blogs;
        private readonly InternalEntitySet<Post> _posts;

        #endregion Fields

        #region Contructor

        partial void Initialize();

        public NTierDemoDataContext(Func<INTierDemoDataService> dataServiceFactory)
        {
            _dataServiceFactory = dataServiceFactory;
            _users = CreateAndRegisterInternalEntitySet<User>();
            _blogs = CreateAndRegisterInternalEntitySet<Blog>();
            _posts = CreateAndRegisterInternalEntitySet<Post>();
            Initialize();
        }

        public NTierDemoDataContext(IChannelFactory<INTierDemoDataService> channelFactory)
            : this(channelFactory.CreateChannel)
        {
        }

        public NTierDemoDataContext(string endpointConfigurationName = "NTierDemoDataService")
            : this(CreateChannelFactory(endpointConfigurationName).CreateChannel)
        {
        }

        private static ChannelFactory<INTierDemoDataService> CreateChannelFactory(string endpointConfigurationName)
        {
            var channelFactory = string.IsNullOrEmpty(endpointConfigurationName)
                ? new ChannelFactory<INTierDemoDataService>()
                : new ChannelFactory<INTierDemoDataService>(endpointConfigurationName);
            return channelFactory;
        }

        #endregion Contructor

        #region Entities

        #region Users

        public IEntitySet<User> Users
        {
            get
            {
                if (userEntitySet == null)
                {
                    userEntitySet = CreateEntitySet<User>(_users, AttachWithRelations, GetUsers);
                }
                return userEntitySet;
            }
        }
        private IEntitySet<User> userEntitySet;

        public void Add(User entity)
        {
            Users.Add(entity);
        }

        public void Delete(User entity)
        {
            Users.Delete(entity);
        }

        public void Attach(User entity)
        {
            Users.Attach(entity);
        }

        public void AttachAsModified(User entity, User original)
        {
            Users.AttachAsModified(entity, original);
        }

        public void Detach(User entity)
        {
            Users.Detach(entity);
        }

        private QueryResult<User> GetUsers(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetUsers(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private User AttachWithRelations(User entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _users.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            User existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _users.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _users.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Blogs.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Blog item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Blog item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Blogs.Count > 0)
            {
                foreach (var item in entity.Blogs.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Blogs.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Owner")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Blogs.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Owner = entity;
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Users.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Users.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Users

        #region Blogs

        public IEntitySet<Blog> Blogs
        {
            get
            {
                if (blogEntitySet == null)
                {
                    blogEntitySet = CreateEntitySet<Blog>(_blogs, AttachWithRelations, GetBlogs);
                }
                return blogEntitySet;
            }
        }
        private IEntitySet<Blog> blogEntitySet;

        public void Add(Blog entity)
        {
            Blogs.Add(entity);
        }

        public void Delete(Blog entity)
        {
            Blogs.Delete(entity);
        }

        public void Attach(Blog entity)
        {
            Blogs.Attach(entity);
        }

        public void AttachAsModified(Blog entity, Blog original)
        {
            Blogs.AttachAsModified(entity, original);
        }

        public void Detach(Blog entity)
        {
            Blogs.Detach(entity);
        }

        private QueryResult<Blog> GetBlogs(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetBlogs(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Blog AttachWithRelations(Blog entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _blogs.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Blog existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _blogs.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _blogs.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Owner")
                    {
                        var relation = entity[e.PropertyName] as User;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Owner != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Owner, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Owner.Equals(existingEntity.Owner))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Owner))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Blogs")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Owner = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Blogs.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Blogs.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Blogs.Add(entity);
                            }
                        }
                    }
                }
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Posts.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Post item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Post item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Posts.Count > 0)
            {
                foreach (var item in entity.Posts.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Blogs.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Blogs.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Blogs

        #region Posts

        public IEntitySet<Post> Posts
        {
            get
            {
                if (postEntitySet == null)
                {
                    postEntitySet = CreateEntitySet<Post>(_posts, AttachWithRelations, GetPosts);
                }
                return postEntitySet;
            }
        }
        private IEntitySet<Post> postEntitySet;

        public void Add(Post entity)
        {
            Posts.Add(entity);
        }

        public void Delete(Post entity)
        {
            Posts.Delete(entity);
        }

        public void Attach(Post entity)
        {
            Posts.Attach(entity);
        }

        public void AttachAsModified(Post entity, Post original)
        {
            Posts.AttachAsModified(entity, original);
        }

        public void Detach(Post entity)
        {
            Posts.Detach(entity);
        }

        private QueryResult<Post> GetPosts(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetPosts(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Post AttachWithRelations(Post entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _posts.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Post existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _posts.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _posts.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Posts.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Posts.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Posts

        #endregion Entities

        #region Submit Changes

        protected override NTierDemoResultSet SubmitChanges(ClientInfo clientInfo)
        {
            // get reduced change set
            var changeSet = GetChangeSet();

            if (!changeSet.IsEmpty)
            {
                var service = _dataServiceFactory();
                try
                {
                    // submit data
                    var resultSet = service.SubmitChanges(clientInfo, changeSet);
                    return resultSet;
                }
                finally
                {
                    var client = service as ICommunicationObject;
                    if (client != null)
                    {
                        if (client.State == CommunicationState.Faulted)
                        {
                            client.Abort();
                        }
                        else
                        {
                            client.Close();
                        }
                    }
                }
            }
            else
            {
                // return empty result set
                return new NTierDemoResultSet(changeSet);
            }
        }

        private NTierDemoChangeSet GetChangeSet()
        {
            IEnumerable<User> users;
            lock (_users.SyncRoot)
            {
                users = _users.GetAllEntities();
            }
            IEnumerable<Blog> blogs;
            lock (_blogs.SyncRoot)
            {
                blogs = _blogs.GetAllEntities();
            }
            IEnumerable<Post> posts;
            lock (_posts.SyncRoot)
            {
                posts = _posts.GetAllEntities();
            }
            // get reduced change set
            var changeSet = new NTierDemoChangeSet(
                users, 
                blogs, 
                posts);

            return changeSet;
        }

        protected override void Refresh(NTierDemoResultSet resultSet)
        {
            lock (_users.SyncRoot)
            {
                Refresh(_users, resultSet.Users == null ? null : resultSet.Users.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_blogs.SyncRoot)
            {
                Refresh(_blogs, resultSet.Blogs == null ? null : resultSet.Blogs.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_posts.SyncRoot)
            {
                Refresh(_posts, resultSet.Posts == null ? null : resultSet.Posts.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
        }

        protected override void HandleConcurrencyConflicts(NTierDemoResultSet resultSet)
        {
            var entities = new List<StateEntry>();

            lock (_users.SyncRoot)
            {
                if (resultSet.UserConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.UserConcurrencyConflicts
                            .Select(store => new StateEntry(_users.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_blogs.SyncRoot)
            {
                if (resultSet.BlogConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.BlogConcurrencyConflicts
                            .Select(store => new StateEntry(_blogs.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_posts.SyncRoot)
            {
                if (resultSet.PostConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.PostConcurrencyConflicts
                            .Select(store => new StateEntry(_posts.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }

            throw new OptimisticConcurrencyException(entities);
        }

        #endregion Submit Changes
    }
}
