//------------------------------------------------------------------------------
// <autogenerated>
//   This file was generated by T4 code generator DemoModel.tt.
//   Any changes made to this file manually may cause incorrect behavior
//   and will be lost next time the file is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;
using System.Data;
using System.Linq;
using System.ServiceModel;
using System.Transactions;
using ConcurrencyDemo.Common.Domain.Model.ConcurrencyTest;
using ConcurrencyDemo.Common.Domain.Service.Contracts;
using NTier.Client.Domain;
using NTier.Client.Domain.Service.ChannelFactory;
using NTier.Common.Domain.Model;

namespace ConcurrencyDemo.Client.Domain
{
    public sealed partial class ConcurrencyTestDataContext : DataContext<ConcurrencyTestResultSet>, IConcurrencyTestDataContext
    {
        #region Fields

        private readonly Func<IConcurrencyTestDataService> _dataServiceFactory;
        private readonly InternalEntitySet<ARecord> _aRecords;
        private readonly InternalEntitySet<BRecord> _bRecords;
        private readonly InternalEntitySet<CRecord> _cRecords;

        #endregion Fields

        #region Contructor

        partial void Initialize();

        public ConcurrencyTestDataContext(Func<IConcurrencyTestDataService> dataServiceFactory)
        {
            _dataServiceFactory = dataServiceFactory;
            _aRecords = CreateAndRegisterInternalEntitySet<ARecord>();
            _bRecords = CreateAndRegisterInternalEntitySet<BRecord>();
            _cRecords = CreateAndRegisterInternalEntitySet<CRecord>();
            Initialize();
        }

        public ConcurrencyTestDataContext(IChannelFactory<IConcurrencyTestDataService> channelFactory)
            : this(channelFactory.CreateChannel)
        {
        }

        public ConcurrencyTestDataContext(string endpointConfigurationName = "ConcurrencyTestDataService")
            : this(CreateChannelFactory(endpointConfigurationName).CreateChannel)
        {
        }

        private static ChannelFactory<IConcurrencyTestDataService> CreateChannelFactory(string endpointConfigurationName)
        {
            var channelFactory = string.IsNullOrEmpty(endpointConfigurationName)
                ? new ChannelFactory<IConcurrencyTestDataService>()
                : new ChannelFactory<IConcurrencyTestDataService>(endpointConfigurationName);
            return channelFactory;
        }

        #endregion Contructor

        #region Entities

        #region ARecords

        public IEntitySet<ARecord> ARecords
        {
            get
            {
                if (aRecordEntitySet == null)
                {
                    aRecordEntitySet = CreateEntitySet<ARecord>(_aRecords, AttachWithRelations, GetARecords);
                }
                return aRecordEntitySet;
            }
        }
        private IEntitySet<ARecord> aRecordEntitySet;

        public void Add(ARecord entity)
        {
            ARecords.Add(entity);
        }

        public void Delete(ARecord entity)
        {
            ARecords.Delete(entity);
        }

        public void Attach(ARecord entity)
        {
            ARecords.Attach(entity);
        }

        public void AttachAsModified(ARecord entity, ARecord original)
        {
            ARecords.AttachAsModified(entity, original);
        }

        public void Detach(ARecord entity)
        {
            ARecords.Detach(entity);
        }

        private QueryResult<ARecord> GetARecords(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetARecords(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private ARecord AttachWithRelations(ARecord entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _aRecords.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            ARecord existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _aRecords.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _aRecords.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (ARecords.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (ARecords.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion ARecords

        #region BRecords

        public IEntitySet<BRecord> BRecords
        {
            get
            {
                if (bRecordEntitySet == null)
                {
                    bRecordEntitySet = CreateEntitySet<BRecord>(_bRecords, AttachWithRelations, GetBRecords);
                }
                return bRecordEntitySet;
            }
        }
        private IEntitySet<BRecord> bRecordEntitySet;

        public void Add(BRecord entity)
        {
            BRecords.Add(entity);
        }

        public void Delete(BRecord entity)
        {
            BRecords.Delete(entity);
        }

        public void Attach(BRecord entity)
        {
            BRecords.Attach(entity);
        }

        public void AttachAsModified(BRecord entity, BRecord original)
        {
            BRecords.AttachAsModified(entity, original);
        }

        public void Detach(BRecord entity)
        {
            BRecords.Detach(entity);
        }

        private QueryResult<BRecord> GetBRecords(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetBRecords(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private BRecord AttachWithRelations(BRecord entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _bRecords.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            BRecord existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _bRecords.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _bRecords.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (BRecords.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (BRecords.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion BRecords

        #region CRecords

        public IEntitySet<CRecord> CRecords
        {
            get
            {
                if (cRecordEntitySet == null)
                {
                    cRecordEntitySet = CreateEntitySet<CRecord>(_cRecords, AttachWithRelations, GetCRecords);
                }
                return cRecordEntitySet;
            }
        }
        private IEntitySet<CRecord> cRecordEntitySet;

        public void Add(CRecord entity)
        {
            CRecords.Add(entity);
        }

        public void Delete(CRecord entity)
        {
            CRecords.Delete(entity);
        }

        public void Attach(CRecord entity)
        {
            CRecords.Attach(entity);
        }

        public void AttachAsModified(CRecord entity, CRecord original)
        {
            CRecords.AttachAsModified(entity, original);
        }

        public void Detach(CRecord entity)
        {
            CRecords.Detach(entity);
        }

        private QueryResult<CRecord> GetCRecords(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetCRecords(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private CRecord AttachWithRelations(CRecord entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _cRecords.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            CRecord existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _cRecords.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _cRecords.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (CRecords.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (CRecords.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion CRecords

        #endregion Entities

        #region Submit Changes

        protected override ConcurrencyTestResultSet SubmitChanges(ClientInfo clientInfo)
        {
            // get reduced change set
            var changeSet = GetChangeSet();

            if (!changeSet.IsEmpty)
            {
                var service = _dataServiceFactory();
                try
                {
                    // submit data
                    var resultSet = service.SubmitChanges(clientInfo, changeSet);
                    return resultSet;
                }
                finally
                {
                    var client = service as ICommunicationObject;
                    if (client != null)
                    {
                        if (client.State == CommunicationState.Faulted)
                        {
                            client.Abort();
                        }
                        else
                        {
                            client.Close();
                        }
                    }
                }
            }
            else
            {
                // return empty result set
                return new ConcurrencyTestResultSet(changeSet);
            }
        }

        private ConcurrencyTestChangeSet GetChangeSet()
        {
            IEnumerable<ARecord> aRecords;
            lock (_aRecords.SyncRoot)
            {
                aRecords = _aRecords.GetAllEntities();
            }
            IEnumerable<BRecord> bRecords;
            lock (_bRecords.SyncRoot)
            {
                bRecords = _bRecords.GetAllEntities();
            }
            IEnumerable<CRecord> cRecords;
            lock (_cRecords.SyncRoot)
            {
                cRecords = _cRecords.GetAllEntities();
            }
            // get reduced change set
            var changeSet = new ConcurrencyTestChangeSet(
                aRecords, 
                bRecords, 
                cRecords);

            return changeSet;
        }

        protected override void Refresh(ConcurrencyTestResultSet resultSet)
        {
            lock (_aRecords.SyncRoot)
            {
                Refresh(_aRecords, resultSet.ARecords == null ? null : resultSet.ARecords.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_bRecords.SyncRoot)
            {
                Refresh(_bRecords, resultSet.BRecords == null ? null : resultSet.BRecords.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_cRecords.SyncRoot)
            {
                Refresh(_cRecords, resultSet.CRecords == null ? null : resultSet.CRecords.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
        }

        protected override void HandleConcurrencyConflicts(ConcurrencyTestResultSet resultSet)
        {
            var entities = new List<StateEntry>();

            lock (_aRecords.SyncRoot)
            {
                if (resultSet.ARecordConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.ARecordConcurrencyConflicts
                            .Select(store => new StateEntry(_aRecords.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_bRecords.SyncRoot)
            {
                if (resultSet.BRecordConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.BRecordConcurrencyConflicts
                            .Select(store => new StateEntry(_bRecords.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_cRecords.SyncRoot)
            {
                if (resultSet.CRecordConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.CRecordConcurrencyConflicts
                            .Select(store => new StateEntry(_cRecords.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }

            throw new OptimisticConcurrencyException(entities);
        }

        #endregion Submit Changes
    }
}
