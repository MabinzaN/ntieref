//------------------------------------------------------------------------------
// <autogenerated>
//   This file was generated by T4 code generator NorthwindModel.tt.
//   Any changes made to this file manually may cause incorrect behavior
//   and will be lost next time the file is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;
using System.Data;
using System.Linq;
using System.ServiceModel;
using System.Transactions;
using IntegrationTest.Common.Domain.Model.Northwind;
using IntegrationTest.Common.Domain.Service.Contracts;
using NTier.Client.Domain;
using NTier.Client.Domain.Service.ChannelFactory;
using NTier.Common.Domain.Model;

namespace IntegrationTest.Client.Domain
{
    public sealed partial class NorthwindDataContext : DataContext<NorthwindResultSet>, INorthwindDataContext
    {
        #region Private Members

        [Import(typeof(IChannelFactory<INorthwindDataService>))]
        private IChannelFactory<INorthwindDataService> ChannelFactory { get; set; }

        private readonly InternalEntitySet<Category> _categories;
        private readonly InternalEntitySet<Employee> _employees;
        private readonly InternalEntitySet<OrderDetail> _orderDetails;
        private readonly InternalEntitySet<Order> _orders;
        private readonly InternalEntitySet<Product> _products;
        private readonly InternalEntitySet<Region> _regions;
        private readonly InternalEntitySet<Shipper> _shippers;
        private readonly InternalEntitySet<Supplier> _suppliers;
        private readonly InternalEntitySet<Territory> _territories;
        private readonly InternalEntitySet<DemographicGroup> _customerDemographics;
        private readonly InternalEntitySet<Customer> _customers;
        private readonly InternalEntitySet<DynamicContentEntity> _dynamicContentEntities;

        #endregion Private Members

        #region Contructor

        partial void Initialize();

        private NorthwindDataContext(bool dummyParameter)
        {
            _categories = CreateAndRegisterInternalEntitySet<Category>();
            _employees = CreateAndRegisterInternalEntitySet<Employee>();
            _orderDetails = CreateAndRegisterInternalEntitySet<OrderDetail>();
            _orders = CreateAndRegisterInternalEntitySet<Order>();
            _products = CreateAndRegisterInternalEntitySet<Product>();
            _regions = CreateAndRegisterInternalEntitySet<Region>();
            _shippers = CreateAndRegisterInternalEntitySet<Shipper>();
            _suppliers = CreateAndRegisterInternalEntitySet<Supplier>();
            _territories = CreateAndRegisterInternalEntitySet<Territory>();
            _customerDemographics = CreateAndRegisterInternalEntitySet<DemographicGroup>();
            _customers = CreateAndRegisterInternalEntitySet<Customer>();
            _dynamicContentEntities = CreateAndRegisterInternalEntitySet<DynamicContentEntity>();
        }

        public NorthwindDataContext(string endpointConfigurationName = "NorthwindDataService")
            : this(true)
        {
            #region MEF composition: inject service factory

            var catalog = new System.ComponentModel.Composition.Hosting.AggregateCatalog();

            // AppDomain.CurrentDomain.BaseDirectory
            var directoryCatalog = new System.ComponentModel.Composition.Hosting.DirectoryCatalog(".");
            catalog.Catalogs.Add(directoryCatalog);

            // ASP.NET / Visual Studio dev webserver uses bin subdirectory to store assemblies
            var direcotry = System.IO.Path.Combine(directoryCatalog.FullPath, "bin");
            if (System.IO.Directory.Exists(direcotry))
            {
                directoryCatalog = new System.ComponentModel.Composition.Hosting.DirectoryCatalog(direcotry);
                catalog.Catalogs.Add(directoryCatalog);
            }
            var container = new System.ComponentModel.Composition.Hosting.CompositionContainer(catalog);

            container.ComposeExportedValue(endpointConfigurationName);
            container.ComposeParts(this);

            #endregion

            Initialize();
        }

        public NorthwindDataContext(IChannelFactory<INorthwindDataService> channelFactory)
            : this(true)
        {
            this.ChannelFactory = channelFactory;
            Initialize();
        }

        #endregion Contructor

        #region Entities

        #region Categories

        public IEntitySet<Category> Categories
        {
            get
            {
                if (categoryEntitySet == null)
                {
                    categoryEntitySet = CreateEntitySet<Category>(_categories, AttachWithRelations, GetCategories);
                }
                return categoryEntitySet;
            }
        }
        private IEntitySet<Category> categoryEntitySet;

        public void Add(Category entity)
        {
            Categories.Add(entity);
        }

        public void Delete(Category entity)
        {
            Categories.Delete(entity);
        }

        public void Attach(Category entity)
        {
            Categories.Attach(entity);
        }

        public void AttachAsModified(Category entity, Category original)
        {
            Categories.AttachAsModified(entity, original);
        }

        public void Detach(Category entity)
        {
            Categories.Detach(entity);
        }

        private QueryResult<Category> GetCategories(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetCategories(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Category AttachWithRelations(Category entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _categories.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Category existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _categories.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _categories.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Categories.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Categories.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Categories

        #region Employees

        public IEntitySet<Employee> Employees
        {
            get
            {
                if (employeeEntitySet == null)
                {
                    employeeEntitySet = CreateEntitySet<Employee>(_employees, AttachWithRelations, GetEmployees);
                }
                return employeeEntitySet;
            }
        }
        private IEntitySet<Employee> employeeEntitySet;

        public void Add(Employee entity)
        {
            Employees.Add(entity);
        }

        public void Delete(Employee entity)
        {
            Employees.Delete(entity);
        }

        public void Attach(Employee entity)
        {
            Employees.Attach(entity);
        }

        public void AttachAsModified(Employee entity, Employee original)
        {
            Employees.AttachAsModified(entity, original);
        }

        public void Detach(Employee entity)
        {
            Employees.Detach(entity);
        }

        private QueryResult<Employee> GetEmployees(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetEmployees(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Employee AttachWithRelations(Employee entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _employees.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Employee existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _employees.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _employees.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Employees1.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Employee item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Employee item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Employees1.Count > 0)
            {
                foreach (var item in entity.Employees1.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Employees1.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employee1")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Employees1.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Employee1 = entity;
                                }
                            }
                        }
                    }
                }
            }

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Employee1")
                    {
                        var relation = entity[e.PropertyName] as Employee;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Employee1 != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Employee1, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Employee1.Equals(existingEntity.Employee1))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Employee1))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employees1")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Employee1 = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Employees1.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Employees1.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Employees1.Add(entity);
                            }
                        }
                    }
                }
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Orders.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Order item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Order item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Orders.Count > 0)
            {
                foreach (var item in entity.Orders.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Orders.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employee")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Orders.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Employee = entity;
                                }
                            }
                        }
                    }
                }
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Territories.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Territory item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Territory item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Territories.Count > 0)
            {
                foreach (var item in entity.Territories.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Employees.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Employees.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Employees

        #region OrderDetails

        private IEntitySet<OrderDetail> OrderDetails
        {
            get
            {
                if (orderDetailEntitySet == null)
                {
                    orderDetailEntitySet = CreateEntitySet<OrderDetail>(_orderDetails, AttachWithRelations, null);
                }
                return orderDetailEntitySet;
            }
        }
        private IEntitySet<OrderDetail> orderDetailEntitySet;

        public void SetMergeOptionForOrderDetails(MergeOption mergeOption)
        {
            OrderDetails.MergeOption = mergeOption;
        }

        public MergeOption GetMergeOptionOfOrderDetails()
        {
            return OrderDetails.MergeOption;
        }

        private void Add(OrderDetail entity)
        {
            OrderDetails.Add(entity);
        }

        private void Delete(OrderDetail entity)
        {
            OrderDetails.Delete(entity);
        }

        private void Attach(OrderDetail entity)
        {
            OrderDetails.Attach(entity);
        }

        private void AttachAsModified(OrderDetail entity, OrderDetail original)
        {
            OrderDetails.AttachAsModified(entity, original);
        }

        private void Detach(OrderDetail entity)
        {
            OrderDetails.Detach(entity);
        }

        private OrderDetail AttachWithRelations(OrderDetail entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _orderDetails.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            OrderDetail existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _orderDetails.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _orderDetails.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Order")
                    {
                        var relation = entity[e.PropertyName] as Order;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Order != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Order, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Order.Equals(existingEntity.Order))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Order))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("OrderDetails")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Order = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.OrderDetails.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.OrderDetails.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.OrderDetails.Add(entity);
                            }
                        }
                    }
                }
            }

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Product")
                    {
                        var relation = entity[e.PropertyName] as Product;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Product != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Product, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Product.Equals(existingEntity.Product))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Product))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("OrderDetails")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Product = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.OrderDetails.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.OrderDetails.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.OrderDetails.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (OrderDetails.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (OrderDetails.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion OrderDetails

        #region Orders

        public IEntitySet<Order> Orders
        {
            get
            {
                if (orderEntitySet == null)
                {
                    orderEntitySet = CreateEntitySet<Order>(_orders, AttachWithRelations, GetOrders);
                }
                return orderEntitySet;
            }
        }
        private IEntitySet<Order> orderEntitySet;

        public void Add(Order entity)
        {
            Orders.Add(entity);
        }

        public void Delete(Order entity)
        {
            Orders.Delete(entity);
        }

        public void Attach(Order entity)
        {
            Orders.Attach(entity);
        }

        public void AttachAsModified(Order entity, Order original)
        {
            Orders.AttachAsModified(entity, original);
        }

        public void Detach(Order entity)
        {
            Orders.Detach(entity);
        }

        private QueryResult<Order> GetOrders(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetOrders(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Order AttachWithRelations(Order entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _orders.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Order existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _orders.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _orders.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Employee")
                    {
                        var relation = entity[e.PropertyName] as Employee;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Employee != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Employee, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Employee.Equals(existingEntity.Employee))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Employee))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Employee = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.OrderDetails.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (OrderDetail item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (OrderDetail item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.OrderDetails.Count > 0)
            {
                foreach (var item in entity.OrderDetails.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.OrderDetails.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Order")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.OrderDetails.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Order = entity;
                                }
                            }
                        }
                    }
                }
            }

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Shipper")
                    {
                        var relation = entity[e.PropertyName] as Shipper;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Shipper != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Shipper, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Shipper.Equals(existingEntity.Shipper))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Shipper))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Shipper = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Customer")
                    {
                        var relation = entity[e.PropertyName] as Customer;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Customer != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Customer, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Customer.Equals(existingEntity.Customer))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Customer))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Customer = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Orders.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Orders.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Orders

        #region Products

        public IEntitySet<Product> Products
        {
            get
            {
                if (productEntitySet == null)
                {
                    productEntitySet = CreateEntitySet<Product>(_products, AttachWithRelations, GetProducts);
                }
                return productEntitySet;
            }
        }
        private IEntitySet<Product> productEntitySet;

        public void Add(Product entity)
        {
            Products.Add(entity);
        }

        public void Delete(Product entity)
        {
            Products.Delete(entity);
        }

        public void Attach(Product entity)
        {
            Products.Attach(entity);
        }

        public void AttachAsModified(Product entity, Product original)
        {
            Products.AttachAsModified(entity, original);
        }

        public void Detach(Product entity)
        {
            Products.Detach(entity);
        }

        private QueryResult<Product> GetProducts(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetProducts(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Product AttachWithRelations(Product entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _products.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Product existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _products.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _products.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Category")
                    {
                        var relation = entity[e.PropertyName] as Category;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Category != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Category, insertMode, mergeOption, referenceTrackingList);
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.OrderDetails.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (OrderDetail item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (OrderDetail item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.OrderDetails.Count > 0)
            {
                foreach (var item in entity.OrderDetails.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.OrderDetails.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Product")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.OrderDetails.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Product = entity;
                                }
                            }
                        }
                    }
                }
            }

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Supplier")
                    {
                        var relation = entity[e.PropertyName] as Supplier;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Supplier != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Supplier, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Supplier.Equals(existingEntity.Supplier))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Supplier))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Products")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Supplier = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Products.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Products.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Products.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Products.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Products.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Products

        #region Regions

        public IEntitySet<Region> Regions
        {
            get
            {
                if (regionEntitySet == null)
                {
                    regionEntitySet = CreateEntitySet<Region>(_regions, AttachWithRelations, GetRegions);
                }
                return regionEntitySet;
            }
        }
        private IEntitySet<Region> regionEntitySet;

        public void Add(Region entity)
        {
            Regions.Add(entity);
        }

        public void Delete(Region entity)
        {
            Regions.Delete(entity);
        }

        public void Attach(Region entity)
        {
            Regions.Attach(entity);
        }

        public void AttachAsModified(Region entity, Region original)
        {
            Regions.AttachAsModified(entity, original);
        }

        public void Detach(Region entity)
        {
            Regions.Detach(entity);
        }

        private QueryResult<Region> GetRegions(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetRegions(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Region AttachWithRelations(Region entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _regions.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Region existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _regions.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _regions.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Territories.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Territory item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Territory item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Territories.Count > 0)
            {
                foreach (var item in entity.Territories.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Territories.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Region")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Territories.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Region = entity;
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Regions.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Regions.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Regions

        #region Shippers

        public IEntitySet<Shipper> Shippers
        {
            get
            {
                if (shipperEntitySet == null)
                {
                    shipperEntitySet = CreateEntitySet<Shipper>(_shippers, AttachWithRelations, GetShippers);
                }
                return shipperEntitySet;
            }
        }
        private IEntitySet<Shipper> shipperEntitySet;

        public void Add(Shipper entity)
        {
            Shippers.Add(entity);
        }

        public void Delete(Shipper entity)
        {
            Shippers.Delete(entity);
        }

        public void Attach(Shipper entity)
        {
            Shippers.Attach(entity);
        }

        public void AttachAsModified(Shipper entity, Shipper original)
        {
            Shippers.AttachAsModified(entity, original);
        }

        public void Detach(Shipper entity)
        {
            Shippers.Detach(entity);
        }

        private QueryResult<Shipper> GetShippers(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetShippers(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Shipper AttachWithRelations(Shipper entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _shippers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Shipper existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _shippers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _shippers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Orders.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Order item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Order item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Orders.Count > 0)
            {
                foreach (var item in entity.Orders.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Orders.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Shipper")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Orders.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Shipper = entity;
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Shippers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Shippers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Shippers

        #region Suppliers

        public IEntitySet<Supplier> Suppliers
        {
            get
            {
                if (supplierEntitySet == null)
                {
                    supplierEntitySet = CreateEntitySet<Supplier>(_suppliers, AttachWithRelations, GetSuppliers);
                }
                return supplierEntitySet;
            }
        }
        private IEntitySet<Supplier> supplierEntitySet;

        public void Add(Supplier entity)
        {
            Suppliers.Add(entity);
        }

        public void Delete(Supplier entity)
        {
            Suppliers.Delete(entity);
        }

        public void Attach(Supplier entity)
        {
            Suppliers.Attach(entity);
        }

        public void AttachAsModified(Supplier entity, Supplier original)
        {
            Suppliers.AttachAsModified(entity, original);
        }

        public void Detach(Supplier entity)
        {
            Suppliers.Detach(entity);
        }

        private QueryResult<Supplier> GetSuppliers(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetSuppliers(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Supplier AttachWithRelations(Supplier entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _suppliers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Supplier existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _suppliers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _suppliers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Products.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Product item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Product item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Products.Count > 0)
            {
                foreach (var item in entity.Products.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Products.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Supplier")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Products.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Supplier = entity;
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Suppliers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Suppliers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Suppliers

        #region Territories

        public IEntitySet<Territory> Territories
        {
            get
            {
                if (territoryEntitySet == null)
                {
                    territoryEntitySet = CreateEntitySet<Territory>(_territories, AttachWithRelations, GetTerritories);
                }
                return territoryEntitySet;
            }
        }
        private IEntitySet<Territory> territoryEntitySet;

        public void Add(Territory entity)
        {
            Territories.Add(entity);
        }

        public void Delete(Territory entity)
        {
            Territories.Delete(entity);
        }

        public void Attach(Territory entity)
        {
            Territories.Attach(entity);
        }

        public void AttachAsModified(Territory entity, Territory original)
        {
            Territories.AttachAsModified(entity, original);
        }

        public void Detach(Territory entity)
        {
            Territories.Detach(entity);
        }

        private QueryResult<Territory> GetTerritories(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetTerritories(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Territory AttachWithRelations(Territory entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _territories.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Territory existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _territories.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _territories.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register entity's property changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.PropertyChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.PropertyName == "Region")
                    {
                        var relation = entity[e.PropertyName] as Region;
                        if (relation != null)
                        {
                            Attach(relation);
                        }
                    }
                };
            }

            // attach related entity to context
            if (entity.Region != null)
            {
                var existingRelatedEntity = AttachWithRelations(entity.Region, insertMode, mergeOption, referenceTrackingList);
                // update relation if entity is new to context or relation is new to entity
                if (existingEntity == null || !entity.Region.Equals(existingEntity.Region))
                {
                    if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, entity.Region))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Territories")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Region = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Territories.FirstOrDefault(e => e.Equals(entity));
                                if (entityToReplace != null)
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Territories.Remove(entityToReplace);
                                    }
                                }
                                existingRelatedEntity.Territories.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Territories.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Territories.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Territories

        #region CustomerDemographics

        public IEntitySet<DemographicGroup> CustomerDemographics
        {
            get
            {
                if (demographicGroupEntitySet == null)
                {
                    demographicGroupEntitySet = CreateEntitySet<DemographicGroup>(_customerDemographics, AttachWithRelations, GetCustomerDemographics);
                }
                return demographicGroupEntitySet;
            }
        }
        private IEntitySet<DemographicGroup> demographicGroupEntitySet;

        public void Add(DemographicGroup entity)
        {
            CustomerDemographics.Add(entity);
        }

        public void Delete(DemographicGroup entity)
        {
            CustomerDemographics.Delete(entity);
        }

        public void Attach(DemographicGroup entity)
        {
            CustomerDemographics.Attach(entity);
        }

        public void AttachAsModified(DemographicGroup entity, DemographicGroup original)
        {
            CustomerDemographics.AttachAsModified(entity, original);
        }

        public void Detach(DemographicGroup entity)
        {
            CustomerDemographics.Detach(entity);
        }

        private QueryResult<DemographicGroup> GetCustomerDemographics(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetCustomerDemographics(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private DemographicGroup AttachWithRelations(DemographicGroup entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _customerDemographics.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            DemographicGroup existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _customerDemographics.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _customerDemographics.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Customers.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Customer item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Customer item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Customers.Count > 0)
            {
                foreach (var item in entity.Customers.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Customers.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("CustomerDemographics")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Customers.Replace(item, existingRelatedEntity);
                                }

                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    var entityToReplace = existingRelatedEntity.CustomerDemographics.FirstOrDefault(e => e.Equals(entity));
                                    if (entityToReplace != null)
                                    {
                                        using (entityToReplace.ChangeTrackingPrevention())
                                        {
                                            existingRelatedEntity.CustomerDemographics.Remove(entityToReplace);
                                        }
                                    }
                                    existingRelatedEntity.CustomerDemographics.Add(entity);
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (CustomerDemographics.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (CustomerDemographics.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion CustomerDemographics

        #region Customers

        public IEntitySet<Customer> Customers
        {
            get
            {
                if (customerEntitySet == null)
                {
                    customerEntitySet = CreateEntitySet<Customer>(_customers, AttachWithRelations, GetCustomers);
                }
                return customerEntitySet;
            }
        }
        private IEntitySet<Customer> customerEntitySet;

        public void Add(Customer entity)
        {
            Customers.Add(entity);
        }

        public void Delete(Customer entity)
        {
            Customers.Delete(entity);
        }

        public void Attach(Customer entity)
        {
            Customers.Attach(entity);
        }

        public void AttachAsModified(Customer entity, Customer original)
        {
            Customers.AttachAsModified(entity, original);
        }

        public void Detach(Customer entity)
        {
            Customers.Detach(entity);
        }

        private QueryResult<Customer> GetCustomers(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetCustomers(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Customer AttachWithRelations(Customer entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _customers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Customer existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _customers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _customers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.Orders.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (Order item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (Order item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.Orders.Count > 0)
            {
                foreach (var item in entity.Orders.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.Orders.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Customer")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.Orders.Replace(item, existingRelatedEntity);
                                }
                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    existingRelatedEntity.Customer = entity;
                                }
                            }
                        }
                    }
                }
            }

            // register relation's collection changed event if entity is new to context
            if (existingEntity == null)
            {
                entity.CustomerDemographics.CollectionChanged += (s, e) =>
                {
                    if (entity.IsChangeTrackingPrevented) return;

                    if (e.NewItems != null)
                    {
                        foreach (DemographicGroup item in e.NewItems)
                        {
                            Attach(item);
                        }
                    }
                    //if (e.OldItems != null)
                    //{
                    //    foreach (DemographicGroup item in e.OldItems)
                    //    {
                    //        if (item.ChangeTracker.State == ObjectState.Unchanged)
                    //        {
                    //            item.MarkAsModified();
                    //        }
                    //    }
                    //}
                };
            }

            // attach related entities to context
            if (entity.CustomerDemographics.Count > 0)
            {
                foreach (var item in entity.CustomerDemographics.ToArray())
                {
                    var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    // update relation if entity is new to context or relation is new to entity
                    if (existingEntity == null || !existingEntity.CustomerDemographics.Contains(item))
                    {
                        if (existingRelatedEntity != null && !object.ReferenceEquals(existingRelatedEntity, item))
                        {
                            // check merge options
                            if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Customers")))
                            {
                                using (entity.ChangeTrackingPrevention())
                                {
                                    entity.CustomerDemographics.Replace(item, existingRelatedEntity);
                                }

                                using (existingRelatedEntity.ChangeTrackingPrevention())
                                {
                                    var entityToReplace = existingRelatedEntity.Customers.FirstOrDefault(e => e.Equals(entity));
                                    if (entityToReplace != null)
                                    {
                                        using (entityToReplace.ChangeTrackingPrevention())
                                        {
                                            existingRelatedEntity.Customers.Remove(entityToReplace);
                                        }
                                    }
                                    existingRelatedEntity.Customers.Add(entity);
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (Customers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Customers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion Customers

        #region DynamicContentEntities

        public IEntitySet<DynamicContentEntity> DynamicContentEntities
        {
            get
            {
                if (dynamicContentEntityEntitySet == null)
                {
                    dynamicContentEntityEntitySet = CreateEntitySet<DynamicContentEntity>(_dynamicContentEntities, AttachWithRelations, GetDynamicContentEntities);
                }
                return dynamicContentEntityEntitySet;
            }
        }
        private IEntitySet<DynamicContentEntity> dynamicContentEntityEntitySet;

        public void Add(DynamicContentEntity entity)
        {
            DynamicContentEntities.Add(entity);
        }

        public void Delete(DynamicContentEntity entity)
        {
            DynamicContentEntities.Delete(entity);
        }

        public void Attach(DynamicContentEntity entity)
        {
            DynamicContentEntities.Attach(entity);
        }

        public void AttachAsModified(DynamicContentEntity entity, DynamicContentEntity original)
        {
            DynamicContentEntities.AttachAsModified(entity, original);
        }

        public void Detach(DynamicContentEntity entity)
        {
            DynamicContentEntities.Detach(entity);
        }

        private QueryResult<DynamicContentEntity> GetDynamicContentEntities(ClientInfo clientInfo, Query query)
        {
            var service = ChannelFactory.CreateChannel();
            try
            {
                var result = service.GetDynamicContentEntities(clientInfo, query);
                return result;
            }
            finally
            {
                // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private DynamicContentEntity AttachWithRelations(DynamicContentEntity entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (referenceTrackingList == null)
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _dynamicContentEntities.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            DynamicContentEntity existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _dynamicContentEntities.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _dynamicContentEntities.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (((object)existingEntity) != null && object.ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively

            #endregion

            #region refresh existing entity based on merge options

            if (existingEntity != null && !object.ReferenceEquals(existingEntity, entity))
            {
                if (DynamicContentEntities.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (DynamicContentEntities.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        #endregion DynamicContentEntities

        #endregion Entities

        #region Submit Changes

        protected override NorthwindResultSet SubmitChanges(ClientInfo clientInfo)
        {
            // get reduced change set
            var changeSet = GetChangeSet();

            if (!changeSet.IsEmpty)
            {
                var service = ChannelFactory.CreateChannel();
                try
                {
                    // submit data
                    var resultSet = service.SubmitChanges(clientInfo, changeSet);
                    return resultSet;
                }
                finally
                {
                    // http://omaralzabir.com/do-not-use-using-in-wcf-client/
                    var client = service as ICommunicationObject;
                    if (client != null)
                    {
                        if (client.State == CommunicationState.Faulted)
                        {
                            client.Abort();
                        }
                        else
                        {
                            client.Close();
                        }
                    }
                }
            }
            else
            {
                // return empty result set
                return new NorthwindResultSet(changeSet);
            }
        }

        private NorthwindChangeSet GetChangeSet()
        {
            IEnumerable<Category> categories;
            lock (_categories.SyncRoot)
            {
                categories = _categories.GetAllEntities();
            }
            IEnumerable<Employee> employees;
            lock (_employees.SyncRoot)
            {
                employees = _employees.GetAllEntities();
            }
            IEnumerable<OrderDetail> orderDetails;
            lock (_orderDetails.SyncRoot)
            {
                orderDetails = _orderDetails.GetAllEntities();
            }
            IEnumerable<Order> orders;
            lock (_orders.SyncRoot)
            {
                orders = _orders.GetAllEntities();
            }
            IEnumerable<Product> products;
            lock (_products.SyncRoot)
            {
                products = _products.GetAllEntities();
            }
            IEnumerable<Region> regions;
            lock (_regions.SyncRoot)
            {
                regions = _regions.GetAllEntities();
            }
            IEnumerable<Shipper> shippers;
            lock (_shippers.SyncRoot)
            {
                shippers = _shippers.GetAllEntities();
            }
            IEnumerable<Supplier> suppliers;
            lock (_suppliers.SyncRoot)
            {
                suppliers = _suppliers.GetAllEntities();
            }
            IEnumerable<Territory> territories;
            lock (_territories.SyncRoot)
            {
                territories = _territories.GetAllEntities();
            }
            IEnumerable<DemographicGroup> customerDemographics;
            lock (_customerDemographics.SyncRoot)
            {
                customerDemographics = _customerDemographics.GetAllEntities();
            }
            IEnumerable<Customer> customers;
            lock (_customers.SyncRoot)
            {
                customers = _customers.GetAllEntities();
            }
            IEnumerable<DynamicContentEntity> dynamicContentEntities;
            lock (_dynamicContentEntities.SyncRoot)
            {
                dynamicContentEntities = _dynamicContentEntities.GetAllEntities();
            }
            // get reduced change set
            var changeSet = new NorthwindChangeSet(
                categories, 
                employees, 
                orderDetails, 
                orders, 
                products, 
                regions, 
                shippers, 
                suppliers, 
                territories, 
                customerDemographics, 
                customers, 
                dynamicContentEntities);

            return changeSet;
        }

        protected override void Refresh(NorthwindResultSet resultSet)
        {
            lock (_categories.SyncRoot)
            {
                Refresh(_categories, resultSet.Categories == null ? null : resultSet.Categories.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_employees.SyncRoot)
            {
                Refresh(_employees, resultSet.Employees == null ? null : resultSet.Employees.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_orderDetails.SyncRoot)
            {
                Refresh(_orderDetails, resultSet.OrderDetails == null ? null : resultSet.OrderDetails.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_orders.SyncRoot)
            {
                Refresh(_orders, resultSet.Orders == null ? null : resultSet.Orders.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_products.SyncRoot)
            {
                Refresh(_products, resultSet.Products == null ? null : resultSet.Products.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_regions.SyncRoot)
            {
                Refresh(_regions, resultSet.Regions == null ? null : resultSet.Regions.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_shippers.SyncRoot)
            {
                Refresh(_shippers, resultSet.Shippers == null ? null : resultSet.Shippers.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_suppliers.SyncRoot)
            {
                Refresh(_suppliers, resultSet.Suppliers == null ? null : resultSet.Suppliers.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_territories.SyncRoot)
            {
                Refresh(_territories, resultSet.Territories == null ? null : resultSet.Territories.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_customerDemographics.SyncRoot)
            {
                Refresh(_customerDemographics, resultSet.CustomerDemographics == null ? null : resultSet.CustomerDemographics.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_customers.SyncRoot)
            {
                Refresh(_customers, resultSet.Customers == null ? null : resultSet.Customers.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
            lock (_dynamicContentEntities.SyncRoot)
            {
                Refresh(_dynamicContentEntities, resultSet.DynamicContentEntities == null ? null : resultSet.DynamicContentEntities.Where(e => !resultSet.IsConcurrencyConflict(e)));
            }
        }

        protected override void HandleConcurrencyConflicts(NorthwindResultSet resultSet)
        {
            var entities = new List<StateEntry>();

            lock (_categories.SyncRoot)
            {
                if (resultSet.CategoryConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.CategoryConcurrencyConflicts
                            .Select(store => new StateEntry(_categories.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_employees.SyncRoot)
            {
                if (resultSet.EmployeeConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.EmployeeConcurrencyConflicts
                            .Select(store => new StateEntry(_employees.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_orderDetails.SyncRoot)
            {
                if (resultSet.OrderDetailConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.OrderDetailConcurrencyConflicts
                            .Select(store => new StateEntry(_orderDetails.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_orders.SyncRoot)
            {
                if (resultSet.OrderConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.OrderConcurrencyConflicts
                            .Select(store => new StateEntry(_orders.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_products.SyncRoot)
            {
                if (resultSet.ProductConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.ProductConcurrencyConflicts
                            .Select(store => new StateEntry(_products.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_regions.SyncRoot)
            {
                if (resultSet.RegionConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.RegionConcurrencyConflicts
                            .Select(store => new StateEntry(_regions.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_shippers.SyncRoot)
            {
                if (resultSet.ShipperConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.ShipperConcurrencyConflicts
                            .Select(store => new StateEntry(_shippers.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_suppliers.SyncRoot)
            {
                if (resultSet.SupplierConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.SupplierConcurrencyConflicts
                            .Select(store => new StateEntry(_suppliers.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_territories.SyncRoot)
            {
                if (resultSet.TerritoryConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.TerritoryConcurrencyConflicts
                            .Select(store => new StateEntry(_territories.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_customerDemographics.SyncRoot)
            {
                if (resultSet.DemographicGroupConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.DemographicGroupConcurrencyConflicts
                            .Select(store => new StateEntry(_customerDemographics.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_customers.SyncRoot)
            {
                if (resultSet.CustomerConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.CustomerConcurrencyConflicts
                            .Select(store => new StateEntry(_customers.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }
            lock (_dynamicContentEntities.SyncRoot)
            {
                if (resultSet.DynamicContentEntityConcurrencyConflicts != null)
                {
                    entities.AddRange(
                        resultSet.DynamicContentEntityConcurrencyConflicts
                            .Select(store => new StateEntry(_dynamicContentEntities.FirstOrDefault(local => local.Equals(store)), store)));
                }
            }

            throw new OptimisticConcurrencyException(entities);
        }

        #endregion Submit Changes
    }
}
