//------------------------------------------------------------------------------
// <auto-generated>
//   This file was generated by T4 code generator Northwind.tt.
//   Any changes made to this file manually may cause incorrect behavior
//   and will be lost next time the file is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;
using System.Data;
using System.Linq;
using System.ServiceModel;
using System.Transactions;
using IntegrationTest.Common.Domain.Model.Northwind;
using IntegrationTest.Common.Domain.Service.Contracts;
using NTier.Client.Domain;
using NTier.Client.Domain.Service.ChannelFactory;
using NTier.Common.Domain.Model;

namespace IntegrationTest.Client.Domain
{
    public sealed partial class NorthwindDataContext : DataContext<NorthwindResultSet>, INorthwindDataContext
    {
        #region Fields

        private readonly Func<INorthwindDataService> _dataServiceFactory;

        private readonly Func<INorthwindChangeSetFactory> _changeSetFactoryProvider;

        private readonly InternalEntitySet<Category> _categories;
        private readonly InternalEntitySet<DemographicGroup> _demographicGroups;
        private readonly InternalEntitySet<Customer> _customers;
        private readonly InternalEntitySet<DynamicContentEntity> _dynamicContentEntities;
        private readonly InternalEntitySet<Employee> _employees;
        private readonly InternalEntitySet<Order_Detail> _order_Details;
        private readonly InternalEntitySet<Order> _orders;
        private readonly InternalEntitySet<Product> _products;
        private readonly InternalEntitySet<Region> _regions;
        private readonly InternalEntitySet<Shipper> _shippers;
        private readonly InternalEntitySet<Supplier> _suppliers;
        private readonly InternalEntitySet<Territory> _territories;
 
        private IEntitySet<Category> categoryEntitySet;
        private IEntitySet<DemographicGroup> demographicGroupEntitySet;
        private IEntitySet<Customer> customerEntitySet;
        private IEntitySet<DynamicContentEntity> dynamicContentEntityEntitySet;
        private IEntitySet<Employee> employeeEntitySet;
        private IEntitySet<Order_Detail> order_DetailEntitySet;
        private IEntitySet<Order> orderEntitySet;
        private IEntitySet<Product> productEntitySet;
        private IEntitySet<Region> regionEntitySet;
        private IEntitySet<Shipper> shipperEntitySet;
        private IEntitySet<Supplier> supplierEntitySet;
        private IEntitySet<Territory> territoryEntitySet;

        #endregion Fields

        #region Contructor

        partial void Initialize();

        public NorthwindDataContext(Func<INorthwindDataService> dataServiceFactory, Func<INorthwindChangeSetFactory> changeSetFactoryProvider = null)
        {
            _dataServiceFactory = dataServiceFactory;

            _changeSetFactoryProvider = changeSetFactoryProvider ?? (() => new NorthwindChangeSetFactory());

            _categories = CreateAndRegisterInternalEntitySet<Category>();
            _demographicGroups = CreateAndRegisterInternalEntitySet<DemographicGroup>();
            _customers = CreateAndRegisterInternalEntitySet<Customer>();
            _dynamicContentEntities = CreateAndRegisterInternalEntitySet<DynamicContentEntity>();
            _employees = CreateAndRegisterInternalEntitySet<Employee>();
            _order_Details = CreateAndRegisterInternalEntitySet<Order_Detail>();
            _orders = CreateAndRegisterInternalEntitySet<Order>();
            _products = CreateAndRegisterInternalEntitySet<Product>();
            _regions = CreateAndRegisterInternalEntitySet<Region>();
            _shippers = CreateAndRegisterInternalEntitySet<Shipper>();
            _suppliers = CreateAndRegisterInternalEntitySet<Supplier>();
            _territories = CreateAndRegisterInternalEntitySet<Territory>();

            Initialize();
        }

        public NorthwindDataContext(IChannelFactory<INorthwindDataService> channelFactory, Func<INorthwindChangeSetFactory> changeSetFactoryProvider = null)
            : this(channelFactory.CreateChannel, changeSetFactoryProvider)
        {
        }

        public NorthwindDataContext(string endpointConfigurationName = "NorthwindDataService", Func<INorthwindChangeSetFactory> changeSetFactoryProvider = null)
            : this(CreateChannelFactory(endpointConfigurationName).CreateChannel, changeSetFactoryProvider)
        {
        }

        private static ChannelFactory<INorthwindDataService> CreateChannelFactory(string endpointConfigurationName)
        {
            var channelFactory = string.IsNullOrEmpty(endpointConfigurationName)
                ? new ChannelFactory<INorthwindDataService>()
                : new ChannelFactory<INorthwindDataService>(endpointConfigurationName);
            return channelFactory;
        }

        #endregion Contructor

        #region Entities

        #region Categories

        public IEntitySet<Category> Categories
        {
            get
            {
                if (ReferenceEquals(null, categoryEntitySet))
                {
                    categoryEntitySet = CreateEntitySet<Category>(_categories, AttachWithRelations, OnDetach, GetCategories);
                }

                return categoryEntitySet;
            }
        }

        public void Add(Category entity)
        {
            Categories.Add(entity);
        }

        public void Delete(Category entity)
        {
            Categories.Delete(entity);
        }

        public void Attach(Category entity)
        {
            Categories.Attach(entity);
        }

        public void AttachAsModified(Category entity, Category original)
        {
            Categories.AttachAsModified(entity, original);
        }

        public void Detach(Category entity)
        {
            Categories.Detach(entity);
        }

        private QueryResult<Category> GetCategories(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetCategories(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Category AttachWithRelations(Category entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _categories.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Category existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _categories.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _categories.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Products))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Products.CollectionChanged += On_category_products_collectionChanged;
                }

                // attach related entities to context
                if (entity.Products.Count > 0)
                {
                    foreach (var item in entity.Products.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Products.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Category")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Products.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Category = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Categories.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Categories.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Category entity)
        {
            if (!ReferenceEquals(null, entity.Products))
            {
                entity.Products.CollectionChanged -= On_category_products_collectionChanged;
            }

        }

        private void On_category_products_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Category;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Product item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Categories

        #region DemographicGroups

        public IEntitySet<DemographicGroup> DemographicGroups
        {
            get
            {
                if (ReferenceEquals(null, demographicGroupEntitySet))
                {
                    demographicGroupEntitySet = CreateEntitySet<DemographicGroup>(_demographicGroups, AttachWithRelations, OnDetach, GetDemographicGroups);
                }

                return demographicGroupEntitySet;
            }
        }

        public void Add(DemographicGroup entity)
        {
            DemographicGroups.Add(entity);
        }

        public void Delete(DemographicGroup entity)
        {
            DemographicGroups.Delete(entity);
        }

        public void Attach(DemographicGroup entity)
        {
            DemographicGroups.Attach(entity);
        }

        public void AttachAsModified(DemographicGroup entity, DemographicGroup original)
        {
            DemographicGroups.AttachAsModified(entity, original);
        }

        public void Detach(DemographicGroup entity)
        {
            DemographicGroups.Detach(entity);
        }

        private QueryResult<DemographicGroup> GetDemographicGroups(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetDemographicGroups(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private DemographicGroup AttachWithRelations(DemographicGroup entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _demographicGroups.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            DemographicGroup existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _demographicGroups.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _demographicGroups.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Customers))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Customers.CollectionChanged += On_demographicGroup_customers_collectionChanged;
                }

                // attach related entities to context
                if (entity.Customers.Count > 0)
                {
                    foreach (var item in entity.Customers.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Customers.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("CustomerDemographics")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Customers.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        var entityToReplace = existingRelatedEntity.CustomerDemographics.FirstOrDefault(e => e.Equals(entity));
                                        if (!ReferenceEquals(null, entityToReplace))
                                        {
                                            using (entityToReplace.ChangeTrackingPrevention())
                                            {
                                                existingRelatedEntity.CustomerDemographics.Remove(entityToReplace);
                                            }
                                        }

                                        existingRelatedEntity.CustomerDemographics.Add(entity);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (DemographicGroups.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (DemographicGroups.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(DemographicGroup entity)
        {
            if (!ReferenceEquals(null, entity.Customers))
            {
                entity.Customers.CollectionChanged -= On_demographicGroup_customers_collectionChanged;
            }

        }

        private void On_demographicGroup_customers_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as DemographicGroup;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Customer item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion DemographicGroups

        #region Customers

        public IEntitySet<Customer> Customers
        {
            get
            {
                if (ReferenceEquals(null, customerEntitySet))
                {
                    customerEntitySet = CreateEntitySet<Customer>(_customers, AttachWithRelations, OnDetach, GetCustomers);
                }

                return customerEntitySet;
            }
        }

        public void Add(Customer entity)
        {
            Customers.Add(entity);
        }

        public void Delete(Customer entity)
        {
            Customers.Delete(entity);
        }

        public void Attach(Customer entity)
        {
            Customers.Attach(entity);
        }

        public void AttachAsModified(Customer entity, Customer original)
        {
            Customers.AttachAsModified(entity, original);
        }

        public void Detach(Customer entity)
        {
            Customers.Detach(entity);
        }

        private QueryResult<Customer> GetCustomers(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetCustomers(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Customer AttachWithRelations(Customer entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _customers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Customer existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _customers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _customers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Orders))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Orders.CollectionChanged += On_customer_orders_collectionChanged;
                }

                // attach related entities to context
                if (entity.Orders.Count > 0)
                {
                    foreach (var item in entity.Orders.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Orders.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Customer")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Orders.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Customer = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!ReferenceEquals(null, entity.CustomerDemographics))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.CustomerDemographics.CollectionChanged += On_customer_customerDemographics_collectionChanged;
                }

                // attach related entities to context
                if (entity.CustomerDemographics.Count > 0)
                {
                    foreach (var item in entity.CustomerDemographics.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.CustomerDemographics.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Customers")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.CustomerDemographics.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        var entityToReplace = existingRelatedEntity.Customers.FirstOrDefault(e => e.Equals(entity));
                                        if (!ReferenceEquals(null, entityToReplace))
                                        {
                                            using (entityToReplace.ChangeTrackingPrevention())
                                            {
                                                existingRelatedEntity.Customers.Remove(entityToReplace);
                                            }
                                        }

                                        existingRelatedEntity.Customers.Add(entity);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Customers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Customers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Customer entity)
        {
            if (!ReferenceEquals(null, entity.Orders))
            {
                entity.Orders.CollectionChanged -= On_customer_orders_collectionChanged;
            }

            if (!ReferenceEquals(null, entity.CustomerDemographics))
            {
                entity.CustomerDemographics.CollectionChanged -= On_customer_customerDemographics_collectionChanged;
            }

        }

        private void On_customer_orders_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Customer;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Order item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        private void On_customer_customerDemographics_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Customer;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (DemographicGroup item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Customers

        #region DynamicContentEntities

        public IEntitySet<DynamicContentEntity> DynamicContentEntities
        {
            get
            {
                if (ReferenceEquals(null, dynamicContentEntityEntitySet))
                {
                    dynamicContentEntityEntitySet = CreateEntitySet<DynamicContentEntity>(_dynamicContentEntities, AttachWithRelations, OnDetach, GetDynamicContentEntities);
                }

                return dynamicContentEntityEntitySet;
            }
        }

        public void Add(DynamicContentEntity entity)
        {
            DynamicContentEntities.Add(entity);
        }

        public void Delete(DynamicContentEntity entity)
        {
            DynamicContentEntities.Delete(entity);
        }

        public void Attach(DynamicContentEntity entity)
        {
            DynamicContentEntities.Attach(entity);
        }

        public void AttachAsModified(DynamicContentEntity entity, DynamicContentEntity original)
        {
            DynamicContentEntities.AttachAsModified(entity, original);
        }

        public void Detach(DynamicContentEntity entity)
        {
            DynamicContentEntities.Detach(entity);
        }

        private QueryResult<DynamicContentEntity> GetDynamicContentEntities(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetDynamicContentEntities(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private DynamicContentEntity AttachWithRelations(DynamicContentEntity entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _dynamicContentEntities.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            DynamicContentEntity existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _dynamicContentEntities.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _dynamicContentEntities.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (DynamicContentEntities.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (DynamicContentEntities.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(DynamicContentEntity entity)
        {
        }

        #endregion DynamicContentEntities

        #region Employees

        public IEntitySet<Employee> Employees
        {
            get
            {
                if (ReferenceEquals(null, employeeEntitySet))
                {
                    employeeEntitySet = CreateEntitySet<Employee>(_employees, AttachWithRelations, OnDetach, GetEmployees);
                }

                return employeeEntitySet;
            }
        }

        public void Add(Employee entity)
        {
            Employees.Add(entity);
        }

        public void Delete(Employee entity)
        {
            Employees.Delete(entity);
        }

        public void Attach(Employee entity)
        {
            Employees.Attach(entity);
        }

        public void AttachAsModified(Employee entity, Employee original)
        {
            Employees.AttachAsModified(entity, original);
        }

        public void Detach(Employee entity)
        {
            Employees.Detach(entity);
        }

        private QueryResult<Employee> GetEmployees(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetEmployees(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Employee AttachWithRelations(Employee entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _employees.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Employee existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _employees.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _employees.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            
            // register entity's property changed event if entity is new to context
            if (ReferenceEquals(null, existingEntity))
            {
                entity.PropertyChanged += On_employee_propertyChanged;
            }

            if (!ReferenceEquals(null, entity.Employees1))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Employees1.CollectionChanged += On_employee_employees1_collectionChanged;
                }

                // attach related entities to context
                if (entity.Employees1.Count > 0)
                {
                    foreach (var item in entity.Employees1.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Employees1.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employee1")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Employees1.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Employee1 = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Employee1))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Employee1, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Employee1.Equals(existingEntity.Employee1))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Employee1))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employees1")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Employee1 = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Employees1.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Employees1.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Employees1.Add(entity);
                            }
                        }
                    }
                }
            }

            if (!ReferenceEquals(null, entity.Orders))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Orders.CollectionChanged += On_employee_orders_collectionChanged;
                }

                // attach related entities to context
                if (entity.Orders.Count > 0)
                {
                    foreach (var item in entity.Orders.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Orders.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Employee")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Orders.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Employee = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!ReferenceEquals(null, entity.Territories))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Territories.CollectionChanged += On_employee_territories_collectionChanged;
                }

                // attach related entities to context
                if (entity.Territories.Count > 0)
                {
                    foreach (var item in entity.Territories.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Employees.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Employees.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Employee entity)
        {
            entity.PropertyChanged -= On_employee_propertyChanged;

            if (!ReferenceEquals(null, entity.Employees1))
            {
                entity.Employees1.CollectionChanged -= On_employee_employees1_collectionChanged;
            }

            if (!ReferenceEquals(null, entity.Orders))
            {
                entity.Orders.CollectionChanged -= On_employee_orders_collectionChanged;
            }

            if (!ReferenceEquals(null, entity.Territories))
            {
                entity.Territories.CollectionChanged -= On_employee_territories_collectionChanged;
            }

        }

        private void On_employee_propertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var entity = sender as Employee;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (e.PropertyName == "Employee1")
            {
                var relation = entity[e.PropertyName] as Employee;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }
        }

        private void On_employee_employees1_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Employee;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Employee item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        private void On_employee_orders_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Employee;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Order item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        private void On_employee_territories_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Employee;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Territory item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Employees

        #region Order_Details

        public IEntitySet<Order_Detail> Order_Details
        {
            get
            {
                if (ReferenceEquals(null, order_DetailEntitySet))
                {
                    order_DetailEntitySet = CreateEntitySet<Order_Detail>(_order_Details, AttachWithRelations, OnDetach, GetOrder_Details);
                }

                return order_DetailEntitySet;
            }
        }

        public void Add(Order_Detail entity)
        {
            Order_Details.Add(entity);
        }

        public void Delete(Order_Detail entity)
        {
            Order_Details.Delete(entity);
        }

        public void Attach(Order_Detail entity)
        {
            Order_Details.Attach(entity);
        }

        public void AttachAsModified(Order_Detail entity, Order_Detail original)
        {
            Order_Details.AttachAsModified(entity, original);
        }

        public void Detach(Order_Detail entity)
        {
            Order_Details.Detach(entity);
        }

        private QueryResult<Order_Detail> GetOrder_Details(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetOrder_Details(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Order_Detail AttachWithRelations(Order_Detail entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _order_Details.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Order_Detail existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _order_Details.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _order_Details.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            
            // register entity's property changed event if entity is new to context
            if (ReferenceEquals(null, existingEntity))
            {
                entity.PropertyChanged += On_order_Detail_propertyChanged;
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Order))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Order, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Order.Equals(existingEntity.Order))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Order))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Order_Details")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Order = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Order_Details.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Order_Details.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Order_Details.Add(entity);
                            }
                        }
                    }
                }
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Product))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Product, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Product.Equals(existingEntity.Product))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Product))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Order_Details")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Product = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Order_Details.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Order_Details.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Order_Details.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Order_Details.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Order_Details.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Order_Detail entity)
        {
            entity.PropertyChanged -= On_order_Detail_propertyChanged;

        }

        private void On_order_Detail_propertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var entity = sender as Order_Detail;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (e.PropertyName == "Order")
            {
                var relation = entity[e.PropertyName] as Order;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }

            if (e.PropertyName == "Product")
            {
                var relation = entity[e.PropertyName] as Product;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }
        }

        #endregion Order_Details

        #region Orders

        public IEntitySet<Order> Orders
        {
            get
            {
                if (ReferenceEquals(null, orderEntitySet))
                {
                    orderEntitySet = CreateEntitySet<Order>(_orders, AttachWithRelations, OnDetach, GetOrders);
                }

                return orderEntitySet;
            }
        }

        public void Add(Order entity)
        {
            Orders.Add(entity);
        }

        public void Delete(Order entity)
        {
            Orders.Delete(entity);
        }

        public void Attach(Order entity)
        {
            Orders.Attach(entity);
        }

        public void AttachAsModified(Order entity, Order original)
        {
            Orders.AttachAsModified(entity, original);
        }

        public void Detach(Order entity)
        {
            Orders.Detach(entity);
        }

        private QueryResult<Order> GetOrders(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetOrders(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Order AttachWithRelations(Order entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _orders.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Order existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _orders.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _orders.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            
            // register entity's property changed event if entity is new to context
            if (ReferenceEquals(null, existingEntity))
            {
                entity.PropertyChanged += On_order_propertyChanged;
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Customer))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Customer, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Customer.Equals(existingEntity.Customer))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Customer))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Customer = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Employee))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Employee, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Employee.Equals(existingEntity.Employee))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Employee))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Employee = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            if (!ReferenceEquals(null, entity.Order_Details))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Order_Details.CollectionChanged += On_order_order_Details_collectionChanged;
                }

                // attach related entities to context
                if (entity.Order_Details.Count > 0)
                {
                    foreach (var item in entity.Order_Details.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Order_Details.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Order")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Order_Details.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Order = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Shipper))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Shipper, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Shipper.Equals(existingEntity.Shipper))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Shipper))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Orders")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Shipper = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Orders.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Orders.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Orders.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Orders.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Orders.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Order entity)
        {
            entity.PropertyChanged -= On_order_propertyChanged;

            if (!ReferenceEquals(null, entity.Order_Details))
            {
                entity.Order_Details.CollectionChanged -= On_order_order_Details_collectionChanged;
            }

        }

        private void On_order_propertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var entity = sender as Order;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (e.PropertyName == "Customer")
            {
                var relation = entity[e.PropertyName] as Customer;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }

            if (e.PropertyName == "Employee")
            {
                var relation = entity[e.PropertyName] as Employee;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }

            if (e.PropertyName == "Shipper")
            {
                var relation = entity[e.PropertyName] as Shipper;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }
        }

        private void On_order_order_Details_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Order;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Order_Detail item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Orders

        #region Products

        public IEntitySet<Product> Products
        {
            get
            {
                if (ReferenceEquals(null, productEntitySet))
                {
                    productEntitySet = CreateEntitySet<Product>(_products, AttachWithRelations, OnDetach, GetProducts);
                }

                return productEntitySet;
            }
        }

        public void Add(Product entity)
        {
            Products.Add(entity);
        }

        public void Delete(Product entity)
        {
            Products.Delete(entity);
        }

        public void Attach(Product entity)
        {
            Products.Attach(entity);
        }

        public void AttachAsModified(Product entity, Product original)
        {
            Products.AttachAsModified(entity, original);
        }

        public void Detach(Product entity)
        {
            Products.Detach(entity);
        }

        private QueryResult<Product> GetProducts(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetProducts(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Product AttachWithRelations(Product entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _products.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Product existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _products.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _products.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            
            // register entity's property changed event if entity is new to context
            if (ReferenceEquals(null, existingEntity))
            {
                entity.PropertyChanged += On_product_propertyChanged;
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Category))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Category, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Category.Equals(existingEntity.Category))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Category))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Products")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Category = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Products.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Products.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Products.Add(entity);
                            }
                        }
                    }
                }
            }

            if (!ReferenceEquals(null, entity.Order_Details))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Order_Details.CollectionChanged += On_product_order_Details_collectionChanged;
                }

                // attach related entities to context
                if (entity.Order_Details.Count > 0)
                {
                    foreach (var item in entity.Order_Details.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Order_Details.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Product")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Order_Details.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Product = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Supplier))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Supplier, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Supplier.Equals(existingEntity.Supplier))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Supplier))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Products")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Supplier = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Products.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Products.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Products.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Products.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Products.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Product entity)
        {
            entity.PropertyChanged -= On_product_propertyChanged;

            if (!ReferenceEquals(null, entity.Order_Details))
            {
                entity.Order_Details.CollectionChanged -= On_product_order_Details_collectionChanged;
            }

        }

        private void On_product_propertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var entity = sender as Product;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (e.PropertyName == "Category")
            {
                var relation = entity[e.PropertyName] as Category;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }

            if (e.PropertyName == "Supplier")
            {
                var relation = entity[e.PropertyName] as Supplier;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }
        }

        private void On_product_order_Details_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Product;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Order_Detail item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Products

        #region Regions

        public IEntitySet<Region> Regions
        {
            get
            {
                if (ReferenceEquals(null, regionEntitySet))
                {
                    regionEntitySet = CreateEntitySet<Region>(_regions, AttachWithRelations, OnDetach, GetRegions);
                }

                return regionEntitySet;
            }
        }

        public void Add(Region entity)
        {
            Regions.Add(entity);
        }

        public void Delete(Region entity)
        {
            Regions.Delete(entity);
        }

        public void Attach(Region entity)
        {
            Regions.Attach(entity);
        }

        public void AttachAsModified(Region entity, Region original)
        {
            Regions.AttachAsModified(entity, original);
        }

        public void Detach(Region entity)
        {
            Regions.Detach(entity);
        }

        private QueryResult<Region> GetRegions(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetRegions(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Region AttachWithRelations(Region entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _regions.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Region existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _regions.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _regions.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Territories))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Territories.CollectionChanged += On_region_territories_collectionChanged;
                }

                // attach related entities to context
                if (entity.Territories.Count > 0)
                {
                    foreach (var item in entity.Territories.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Territories.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Region")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Territories.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Region = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Regions.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Regions.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Region entity)
        {
            if (!ReferenceEquals(null, entity.Territories))
            {
                entity.Territories.CollectionChanged -= On_region_territories_collectionChanged;
            }

        }

        private void On_region_territories_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Region;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Territory item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Regions

        #region Shippers

        public IEntitySet<Shipper> Shippers
        {
            get
            {
                if (ReferenceEquals(null, shipperEntitySet))
                {
                    shipperEntitySet = CreateEntitySet<Shipper>(_shippers, AttachWithRelations, OnDetach, GetShippers);
                }

                return shipperEntitySet;
            }
        }

        public void Add(Shipper entity)
        {
            Shippers.Add(entity);
        }

        public void Delete(Shipper entity)
        {
            Shippers.Delete(entity);
        }

        public void Attach(Shipper entity)
        {
            Shippers.Attach(entity);
        }

        public void AttachAsModified(Shipper entity, Shipper original)
        {
            Shippers.AttachAsModified(entity, original);
        }

        public void Detach(Shipper entity)
        {
            Shippers.Detach(entity);
        }

        private QueryResult<Shipper> GetShippers(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetShippers(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Shipper AttachWithRelations(Shipper entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _shippers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Shipper existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _shippers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _shippers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Orders))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Orders.CollectionChanged += On_shipper_orders_collectionChanged;
                }

                // attach related entities to context
                if (entity.Orders.Count > 0)
                {
                    foreach (var item in entity.Orders.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Orders.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Shipper")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Orders.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Shipper = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Shippers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Shippers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Shipper entity)
        {
            if (!ReferenceEquals(null, entity.Orders))
            {
                entity.Orders.CollectionChanged -= On_shipper_orders_collectionChanged;
            }

        }

        private void On_shipper_orders_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Shipper;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Order item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Shippers

        #region Suppliers

        public IEntitySet<Supplier> Suppliers
        {
            get
            {
                if (ReferenceEquals(null, supplierEntitySet))
                {
                    supplierEntitySet = CreateEntitySet<Supplier>(_suppliers, AttachWithRelations, OnDetach, GetSuppliers);
                }

                return supplierEntitySet;
            }
        }

        public void Add(Supplier entity)
        {
            Suppliers.Add(entity);
        }

        public void Delete(Supplier entity)
        {
            Suppliers.Delete(entity);
        }

        public void Attach(Supplier entity)
        {
            Suppliers.Attach(entity);
        }

        public void AttachAsModified(Supplier entity, Supplier original)
        {
            Suppliers.AttachAsModified(entity, original);
        }

        public void Detach(Supplier entity)
        {
            Suppliers.Detach(entity);
        }

        private QueryResult<Supplier> GetSuppliers(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetSuppliers(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Supplier AttachWithRelations(Supplier entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _suppliers.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Supplier existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _suppliers.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _suppliers.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            

            if (!ReferenceEquals(null, entity.Products))
            {
                // register relation's collection changed event if entity is new to context
                if (ReferenceEquals(null, existingEntity))
                {
                    entity.Products.CollectionChanged += On_supplier_products_collectionChanged;
                }

                // attach related entities to context
                if (entity.Products.Count > 0)
                {
                    foreach (var item in entity.Products.ToArray())
                    {
                        var existingRelatedEntity = AttachWithRelations(item, insertMode, mergeOption, referenceTrackingList);

                        // update relation if entity is new to context or relation is new to entity
                        if (ReferenceEquals(null, existingEntity) || !existingEntity.Products.Contains(item))
                        {
                            if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, item))
                            {
                                // check merge options
                                if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Supplier")))
                                {
                                    using (entity.ChangeTrackingPrevention())
                                    {
                                        entity.Products.Replace(item, existingRelatedEntity);
                                    }

                                    using (existingRelatedEntity.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Supplier = entity;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Suppliers.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Suppliers.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Supplier entity)
        {
            if (!ReferenceEquals(null, entity.Products))
            {
                entity.Products.CollectionChanged -= On_supplier_products_collectionChanged;
            }

        }

        private void On_supplier_products_collectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            var entity = sender as Supplier;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (!ReferenceEquals(null, e.NewItems))
            {
                foreach (Product item in e.NewItems)
                {
                    Attach(item);
                }
            }
        }

        #endregion Suppliers

        #region Territories

        public IEntitySet<Territory> Territories
        {
            get
            {
                if (ReferenceEquals(null, territoryEntitySet))
                {
                    territoryEntitySet = CreateEntitySet<Territory>(_territories, AttachWithRelations, OnDetach, GetTerritories);
                }

                return territoryEntitySet;
            }
        }

        public void Add(Territory entity)
        {
            Territories.Add(entity);
        }

        public void Delete(Territory entity)
        {
            Territories.Delete(entity);
        }

        public void Attach(Territory entity)
        {
            Territories.Attach(entity);
        }

        public void AttachAsModified(Territory entity, Territory original)
        {
            Territories.AttachAsModified(entity, original);
        }

        public void Detach(Territory entity)
        {
            Territories.Detach(entity);
        }

        private QueryResult<Territory> GetTerritories(ClientInfo clientInfo, Query query)
        {
            var service = _dataServiceFactory();
            try
            {
                var result = service.GetTerritories(clientInfo, query);
                return result;
            }
            finally
            {
                var client = service as ICommunicationObject;
                if (client != null)
                {
                    if (client.State == CommunicationState.Faulted)
                    {
                        client.Abort();
                    }
                    else
                    {
                        client.Close();
                    }
                }
            }
        }

        private Territory AttachWithRelations(Territory entity, InsertMode insertMode = InsertMode.Attach, MergeOption mergeOption = MergeOption.AppendOnly, List<object> referenceTrackingList = null)
        {
            #region iteration tracking

            if (ReferenceEquals(null, referenceTrackingList))
            {
                referenceTrackingList = new List<object>();
            }

            if (referenceTrackingList.Contains(entity))
            {
                return _territories.GetExisting(entity);
            }
            else
            {
                referenceTrackingList.Add(entity);
            }

            #endregion

            #region add/attach entity

            Territory existingEntity = null;

            switch (insertMode)
            {
                case InsertMode.Add:
                    existingEntity = _territories.Add(entity);
                    break;
                case InsertMode.Attach:
                    existingEntity = _territories.Attach(entity);
                    break;
                default:
                    throw new Exception(string.Format("Implementation Exception: missing action for {0}", insertMode));
            }

            if (!ReferenceEquals(null, existingEntity) && ReferenceEquals(existingEntity, entity))
            {
                return existingEntity;
            }

            #endregion

            #region attach relations recursively
            
            // register entity's property changed event if entity is new to context
            if (ReferenceEquals(null, existingEntity))
            {
                entity.PropertyChanged += On_territory_propertyChanged;
            }

            // attach related entity to context
            if (!ReferenceEquals(null, entity.Region))
            {
                var existingRelatedEntity = AttachWithRelations(entity.Region, insertMode, mergeOption, referenceTrackingList);

                // update relation if entity is new to context or relation is new to entity
                if (ReferenceEquals(null, existingEntity) || !entity.Region.Equals(existingEntity.Region))
                {
                    if (!ReferenceEquals(null, existingRelatedEntity) && !ReferenceEquals(existingRelatedEntity, entity.Region))
                    {
                        // check merge options
                        if (!(mergeOption == MergeOption.PreserveChanges && existingRelatedEntity.ChangeTracker.OriginalValues.ContainsKey("Territories")))
                        {
                            using (entity.ChangeTrackingPrevention())
                            {
                                entity.Region = existingRelatedEntity;
                            }

                            using (existingRelatedEntity.ChangeTrackingPrevention())
                            {
                                var entityToReplace = existingRelatedEntity.Territories.FirstOrDefault(e => e.Equals(entity));
                                if (!ReferenceEquals(null, entityToReplace))
                                {
                                    using (entityToReplace.ChangeTrackingPrevention())
                                    {
                                        existingRelatedEntity.Territories.Remove(entityToReplace);
                                    }
                                }

                                existingRelatedEntity.Territories.Add(entity);
                            }
                        }
                    }
                }
            }

            #endregion

            #region refresh existing entity based on merge options

            if (!ReferenceEquals(null, existingEntity) && !ReferenceEquals(existingEntity, entity))
            {
                if (Territories.MergeOption == MergeOption.OverwriteChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false);
                        existingEntity.AcceptChanges();
                    });
                }
                else if (Territories.MergeOption == MergeOption.PreserveChanges)
                {
                    Invoke(delegate
                    {
                        existingEntity.Refresh(entity, trackChanges: false, preserveExistingChanges: true);
                    });
                }
            }

            #endregion

            return existingEntity;
        }

        private void OnDetach(Territory entity)
        {
            entity.PropertyChanged -= On_territory_propertyChanged;

        }

        private void On_territory_propertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var entity = sender as Territory;
            if (!ReferenceEquals(null, entity) && entity.IsChangeTrackingPrevented)
            {
                return;
            }

            if (e.PropertyName == "Region")
            {
                var relation = entity[e.PropertyName] as Region;
                if (!ReferenceEquals(null, relation))
                {
                    Attach(relation);
                }
            }
        }

        #endregion Territories

        #endregion Entities

        #region Submit Changes

        protected override NorthwindResultSet SubmitChanges(ClientInfo clientInfo)
        {
            // get reduced change set
            var changeSet = GetChangeSet();

            if (!changeSet.IsEmpty)
            {
                var service = _dataServiceFactory();
                try
                {
                    // submit data
                    var resultSet = service.SubmitChanges(clientInfo, changeSet);
                    return resultSet;
                }
                finally
                {
                    var client = service as ICommunicationObject;
                    if (client != null)
                    {
                        if (client.State == CommunicationState.Faulted)
                        {
                            client.Abort();
                        }
                        else
                        {
                            client.Close();
                        }
                    }
                }
            }
            else
            {
                // return empty result set
                return new NorthwindResultSet(changeSet);
            }
        }

        private NorthwindChangeSet GetChangeSet()
        {
            IEnumerable<Category> categories;
            lock (_categories.SyncRoot)
            {
                categories = _categories.GetAllEntities();
            }

            IEnumerable<DemographicGroup> demographicGroups;
            lock (_demographicGroups.SyncRoot)
            {
                demographicGroups = _demographicGroups.GetAllEntities();
            }

            IEnumerable<Customer> customers;
            lock (_customers.SyncRoot)
            {
                customers = _customers.GetAllEntities();
            }

            IEnumerable<DynamicContentEntity> dynamicContentEntities;
            lock (_dynamicContentEntities.SyncRoot)
            {
                dynamicContentEntities = _dynamicContentEntities.GetAllEntities();
            }

            IEnumerable<Employee> employees;
            lock (_employees.SyncRoot)
            {
                employees = _employees.GetAllEntities();
            }

            IEnumerable<Order_Detail> order_Details;
            lock (_order_Details.SyncRoot)
            {
                order_Details = _order_Details.GetAllEntities();
            }

            IEnumerable<Order> orders;
            lock (_orders.SyncRoot)
            {
                orders = _orders.GetAllEntities();
            }

            IEnumerable<Product> products;
            lock (_products.SyncRoot)
            {
                products = _products.GetAllEntities();
            }

            IEnumerable<Region> regions;
            lock (_regions.SyncRoot)
            {
                regions = _regions.GetAllEntities();
            }

            IEnumerable<Shipper> shippers;
            lock (_shippers.SyncRoot)
            {
                shippers = _shippers.GetAllEntities();
            }

            IEnumerable<Supplier> suppliers;
            lock (_suppliers.SyncRoot)
            {
                suppliers = _suppliers.GetAllEntities();
            }

            IEnumerable<Territory> territories;
            lock (_territories.SyncRoot)
            {
                territories = _territories.GetAllEntities();
            }

            // get reduced change set
            var changeSet = _changeSetFactoryProvider().CreateChangeSet(
                categories, 
                demographicGroups, 
                customers, 
                dynamicContentEntities, 
                employees, 
                order_Details, 
                orders, 
                products, 
                regions, 
                shippers, 
                suppliers, 
                territories);

            return changeSet;
        }

        protected override void Refresh(NorthwindResultSet resultSet)
        {
            lock (_categories.SyncRoot)
            {
                Refresh(_categories, resultSet.Categories);
            }

            lock (_demographicGroups.SyncRoot)
            {
                Refresh(_demographicGroups, resultSet.DemographicGroups);
            }

            lock (_customers.SyncRoot)
            {
                Refresh(_customers, resultSet.Customers);
            }

            lock (_dynamicContentEntities.SyncRoot)
            {
                Refresh(_dynamicContentEntities, resultSet.DynamicContentEntities);
            }

            lock (_employees.SyncRoot)
            {
                Refresh(_employees, resultSet.Employees);
            }

            lock (_order_Details.SyncRoot)
            {
                Refresh(_order_Details, resultSet.Order_Details);
            }

            lock (_orders.SyncRoot)
            {
                Refresh(_orders, resultSet.Orders);
            }

            lock (_products.SyncRoot)
            {
                Refresh(_products, resultSet.Products);
            }

            lock (_regions.SyncRoot)
            {
                Refresh(_regions, resultSet.Regions);
            }

            lock (_shippers.SyncRoot)
            {
                Refresh(_shippers, resultSet.Shippers);
            }

            lock (_suppliers.SyncRoot)
            {
                Refresh(_suppliers, resultSet.Suppliers);
            }

            lock (_territories.SyncRoot)
            {
                Refresh(_territories, resultSet.Territories);
            }

        }

        #endregion Submit Changes
    }
}
